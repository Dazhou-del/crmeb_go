// Code generated by gorm.io/gen. DO NOT EDIT.
// Code generated by gorm.io/gen. DO NOT EDIT.
// Code generated by gorm.io/gen. DO NOT EDIT.

package gen

import (
	"context"

	"gorm.io/gorm"
	"gorm.io/gorm/clause"
	"gorm.io/gorm/schema"

	"gorm.io/gen"
	"gorm.io/gen/field"

	"gorm.io/plugin/dbresolver"

	"crmeb_go/internal/model"
)

func newEbUserBrokerageRecord(db *gorm.DB, opts ...gen.DOOption) ebUserBrokerageRecord {
	_ebUserBrokerageRecord := ebUserBrokerageRecord{}

	_ebUserBrokerageRecord.ebUserBrokerageRecordDo.UseDB(db, opts...)
	_ebUserBrokerageRecord.ebUserBrokerageRecordDo.UseModel(&model.EbUserBrokerageRecord{})

	tableName := _ebUserBrokerageRecord.ebUserBrokerageRecordDo.TableName()
	_ebUserBrokerageRecord.ALL = field.NewAsterisk(tableName)
	_ebUserBrokerageRecord.ID = field.NewInt32(tableName, "id")
	_ebUserBrokerageRecord.UID = field.NewInt32(tableName, "uid")
	_ebUserBrokerageRecord.LinkID = field.NewString(tableName, "link_id")
	_ebUserBrokerageRecord.LinkType = field.NewString(tableName, "link_type")
	_ebUserBrokerageRecord.Type = field.NewInt32(tableName, "type")
	_ebUserBrokerageRecord.Title = field.NewString(tableName, "title")
	_ebUserBrokerageRecord.Price = field.NewFloat64(tableName, "price")
	_ebUserBrokerageRecord.Balance = field.NewFloat64(tableName, "balance")
	_ebUserBrokerageRecord.Mark = field.NewString(tableName, "mark")
	_ebUserBrokerageRecord.Status = field.NewBool(tableName, "status")
	_ebUserBrokerageRecord.FrozenTime = field.NewInt32(tableName, "frozen_time")
	_ebUserBrokerageRecord.ThawTime = field.NewInt64(tableName, "thaw_time")
	_ebUserBrokerageRecord.CreateTime = field.NewTime(tableName, "create_time")
	_ebUserBrokerageRecord.UpdateTime = field.NewTime(tableName, "update_time")
	_ebUserBrokerageRecord.BrokerageLevel = field.NewInt32(tableName, "brokerage_level")

	_ebUserBrokerageRecord.fillFieldMap()

	return _ebUserBrokerageRecord
}

// ebUserBrokerageRecord 用户佣金记录表
type ebUserBrokerageRecord struct {
	ebUserBrokerageRecordDo ebUserBrokerageRecordDo

	ALL            field.Asterisk
	ID             field.Int32   // 记录id
	UID            field.Int32   // 用户uid
	LinkID         field.String  // 关联id（orderNo,提现id）
	LinkType       field.String  // 关联类型（order,extract，yue）
	Type           field.Int32   // 类型：1-增加，2-扣减（提现）
	Title          field.String  // 标题
	Price          field.Float64 // 金额
	Balance        field.Float64 // 剩余
	Mark           field.String  // 备注
	Status         field.Bool    // 状态：1-订单创建，2-冻结期，3-完成，4-失效（订单退款），5-提现申请
	FrozenTime     field.Int32   // 冻结期时间（天）
	ThawTime       field.Int64   // 解冻时间
	CreateTime     field.Time    // 添加时间
	UpdateTime     field.Time    // 更新时间
	BrokerageLevel field.Int32   // 分销等级

	fieldMap map[string]field.Expr
}

func (e ebUserBrokerageRecord) Table(newTableName string) *ebUserBrokerageRecord {
	e.ebUserBrokerageRecordDo.UseTable(newTableName)
	return e.updateTableName(newTableName)
}

func (e ebUserBrokerageRecord) As(alias string) *ebUserBrokerageRecord {
	e.ebUserBrokerageRecordDo.DO = *(e.ebUserBrokerageRecordDo.As(alias).(*gen.DO))
	return e.updateTableName(alias)
}

func (e *ebUserBrokerageRecord) updateTableName(table string) *ebUserBrokerageRecord {
	e.ALL = field.NewAsterisk(table)
	e.ID = field.NewInt32(table, "id")
	e.UID = field.NewInt32(table, "uid")
	e.LinkID = field.NewString(table, "link_id")
	e.LinkType = field.NewString(table, "link_type")
	e.Type = field.NewInt32(table, "type")
	e.Title = field.NewString(table, "title")
	e.Price = field.NewFloat64(table, "price")
	e.Balance = field.NewFloat64(table, "balance")
	e.Mark = field.NewString(table, "mark")
	e.Status = field.NewBool(table, "status")
	e.FrozenTime = field.NewInt32(table, "frozen_time")
	e.ThawTime = field.NewInt64(table, "thaw_time")
	e.CreateTime = field.NewTime(table, "create_time")
	e.UpdateTime = field.NewTime(table, "update_time")
	e.BrokerageLevel = field.NewInt32(table, "brokerage_level")

	e.fillFieldMap()

	return e
}

func (e *ebUserBrokerageRecord) WithContext(ctx context.Context) IEbUserBrokerageRecordDo {
	return e.ebUserBrokerageRecordDo.WithContext(ctx)
}

func (e ebUserBrokerageRecord) TableName() string { return e.ebUserBrokerageRecordDo.TableName() }

func (e ebUserBrokerageRecord) Alias() string { return e.ebUserBrokerageRecordDo.Alias() }

func (e ebUserBrokerageRecord) Columns(cols ...field.Expr) gen.Columns {
	return e.ebUserBrokerageRecordDo.Columns(cols...)
}

func (e *ebUserBrokerageRecord) GetFieldByName(fieldName string) (field.OrderExpr, bool) {
	_f, ok := e.fieldMap[fieldName]
	if !ok || _f == nil {
		return nil, false
	}
	_oe, ok := _f.(field.OrderExpr)
	return _oe, ok
}

func (e *ebUserBrokerageRecord) fillFieldMap() {
	e.fieldMap = make(map[string]field.Expr, 15)
	e.fieldMap["id"] = e.ID
	e.fieldMap["uid"] = e.UID
	e.fieldMap["link_id"] = e.LinkID
	e.fieldMap["link_type"] = e.LinkType
	e.fieldMap["type"] = e.Type
	e.fieldMap["title"] = e.Title
	e.fieldMap["price"] = e.Price
	e.fieldMap["balance"] = e.Balance
	e.fieldMap["mark"] = e.Mark
	e.fieldMap["status"] = e.Status
	e.fieldMap["frozen_time"] = e.FrozenTime
	e.fieldMap["thaw_time"] = e.ThawTime
	e.fieldMap["create_time"] = e.CreateTime
	e.fieldMap["update_time"] = e.UpdateTime
	e.fieldMap["brokerage_level"] = e.BrokerageLevel
}

func (e ebUserBrokerageRecord) clone(db *gorm.DB) ebUserBrokerageRecord {
	e.ebUserBrokerageRecordDo.ReplaceConnPool(db.Statement.ConnPool)
	return e
}

func (e ebUserBrokerageRecord) replaceDB(db *gorm.DB) ebUserBrokerageRecord {
	e.ebUserBrokerageRecordDo.ReplaceDB(db)
	return e
}

type ebUserBrokerageRecordDo struct{ gen.DO }

type IEbUserBrokerageRecordDo interface {
	gen.SubQuery
	Debug() IEbUserBrokerageRecordDo
	WithContext(ctx context.Context) IEbUserBrokerageRecordDo
	WithResult(fc func(tx gen.Dao)) gen.ResultInfo
	ReplaceDB(db *gorm.DB)
	ReadDB() IEbUserBrokerageRecordDo
	WriteDB() IEbUserBrokerageRecordDo
	As(alias string) gen.Dao
	Session(config *gorm.Session) IEbUserBrokerageRecordDo
	Columns(cols ...field.Expr) gen.Columns
	Clauses(conds ...clause.Expression) IEbUserBrokerageRecordDo
	Not(conds ...gen.Condition) IEbUserBrokerageRecordDo
	Or(conds ...gen.Condition) IEbUserBrokerageRecordDo
	Select(conds ...field.Expr) IEbUserBrokerageRecordDo
	Where(conds ...gen.Condition) IEbUserBrokerageRecordDo
	Order(conds ...field.Expr) IEbUserBrokerageRecordDo
	Distinct(cols ...field.Expr) IEbUserBrokerageRecordDo
	Omit(cols ...field.Expr) IEbUserBrokerageRecordDo
	Join(table schema.Tabler, on ...field.Expr) IEbUserBrokerageRecordDo
	LeftJoin(table schema.Tabler, on ...field.Expr) IEbUserBrokerageRecordDo
	RightJoin(table schema.Tabler, on ...field.Expr) IEbUserBrokerageRecordDo
	Group(cols ...field.Expr) IEbUserBrokerageRecordDo
	Having(conds ...gen.Condition) IEbUserBrokerageRecordDo
	Limit(limit int) IEbUserBrokerageRecordDo
	Offset(offset int) IEbUserBrokerageRecordDo
	Count() (count int64, err error)
	Scopes(funcs ...func(gen.Dao) gen.Dao) IEbUserBrokerageRecordDo
	Unscoped() IEbUserBrokerageRecordDo
	Create(values ...*model.EbUserBrokerageRecord) error
	CreateInBatches(values []*model.EbUserBrokerageRecord, batchSize int) error
	Save(values ...*model.EbUserBrokerageRecord) error
	First() (*model.EbUserBrokerageRecord, error)
	Take() (*model.EbUserBrokerageRecord, error)
	Last() (*model.EbUserBrokerageRecord, error)
	Find() ([]*model.EbUserBrokerageRecord, error)
	FindInBatch(batchSize int, fc func(tx gen.Dao, batch int) error) (results []*model.EbUserBrokerageRecord, err error)
	FindInBatches(result *[]*model.EbUserBrokerageRecord, batchSize int, fc func(tx gen.Dao, batch int) error) error
	Pluck(column field.Expr, dest interface{}) error
	Delete(...*model.EbUserBrokerageRecord) (info gen.ResultInfo, err error)
	Update(column field.Expr, value interface{}) (info gen.ResultInfo, err error)
	UpdateSimple(columns ...field.AssignExpr) (info gen.ResultInfo, err error)
	Updates(value interface{}) (info gen.ResultInfo, err error)
	UpdateColumn(column field.Expr, value interface{}) (info gen.ResultInfo, err error)
	UpdateColumnSimple(columns ...field.AssignExpr) (info gen.ResultInfo, err error)
	UpdateColumns(value interface{}) (info gen.ResultInfo, err error)
	UpdateFrom(q gen.SubQuery) gen.Dao
	Attrs(attrs ...field.AssignExpr) IEbUserBrokerageRecordDo
	Assign(attrs ...field.AssignExpr) IEbUserBrokerageRecordDo
	Joins(fields ...field.RelationField) IEbUserBrokerageRecordDo
	Preload(fields ...field.RelationField) IEbUserBrokerageRecordDo
	FirstOrInit() (*model.EbUserBrokerageRecord, error)
	FirstOrCreate() (*model.EbUserBrokerageRecord, error)
	FindByPage(offset int, limit int) (result []*model.EbUserBrokerageRecord, count int64, err error)
	ScanByPage(result interface{}, offset int, limit int) (count int64, err error)
	Scan(result interface{}) (err error)
	Returning(value interface{}, columns ...string) IEbUserBrokerageRecordDo
	UnderlyingDB() *gorm.DB
	schema.Tabler
}

func (e ebUserBrokerageRecordDo) Debug() IEbUserBrokerageRecordDo {
	return e.withDO(e.DO.Debug())
}

func (e ebUserBrokerageRecordDo) WithContext(ctx context.Context) IEbUserBrokerageRecordDo {
	return e.withDO(e.DO.WithContext(ctx))
}

func (e ebUserBrokerageRecordDo) ReadDB() IEbUserBrokerageRecordDo {
	return e.Clauses(dbresolver.Read)
}

func (e ebUserBrokerageRecordDo) WriteDB() IEbUserBrokerageRecordDo {
	return e.Clauses(dbresolver.Write)
}

func (e ebUserBrokerageRecordDo) Session(config *gorm.Session) IEbUserBrokerageRecordDo {
	return e.withDO(e.DO.Session(config))
}

func (e ebUserBrokerageRecordDo) Clauses(conds ...clause.Expression) IEbUserBrokerageRecordDo {
	return e.withDO(e.DO.Clauses(conds...))
}

func (e ebUserBrokerageRecordDo) Returning(value interface{}, columns ...string) IEbUserBrokerageRecordDo {
	return e.withDO(e.DO.Returning(value, columns...))
}

func (e ebUserBrokerageRecordDo) Not(conds ...gen.Condition) IEbUserBrokerageRecordDo {
	return e.withDO(e.DO.Not(conds...))
}

func (e ebUserBrokerageRecordDo) Or(conds ...gen.Condition) IEbUserBrokerageRecordDo {
	return e.withDO(e.DO.Or(conds...))
}

func (e ebUserBrokerageRecordDo) Select(conds ...field.Expr) IEbUserBrokerageRecordDo {
	return e.withDO(e.DO.Select(conds...))
}

func (e ebUserBrokerageRecordDo) Where(conds ...gen.Condition) IEbUserBrokerageRecordDo {
	return e.withDO(e.DO.Where(conds...))
}

func (e ebUserBrokerageRecordDo) Order(conds ...field.Expr) IEbUserBrokerageRecordDo {
	return e.withDO(e.DO.Order(conds...))
}

func (e ebUserBrokerageRecordDo) Distinct(cols ...field.Expr) IEbUserBrokerageRecordDo {
	return e.withDO(e.DO.Distinct(cols...))
}

func (e ebUserBrokerageRecordDo) Omit(cols ...field.Expr) IEbUserBrokerageRecordDo {
	return e.withDO(e.DO.Omit(cols...))
}

func (e ebUserBrokerageRecordDo) Join(table schema.Tabler, on ...field.Expr) IEbUserBrokerageRecordDo {
	return e.withDO(e.DO.Join(table, on...))
}

func (e ebUserBrokerageRecordDo) LeftJoin(table schema.Tabler, on ...field.Expr) IEbUserBrokerageRecordDo {
	return e.withDO(e.DO.LeftJoin(table, on...))
}

func (e ebUserBrokerageRecordDo) RightJoin(table schema.Tabler, on ...field.Expr) IEbUserBrokerageRecordDo {
	return e.withDO(e.DO.RightJoin(table, on...))
}

func (e ebUserBrokerageRecordDo) Group(cols ...field.Expr) IEbUserBrokerageRecordDo {
	return e.withDO(e.DO.Group(cols...))
}

func (e ebUserBrokerageRecordDo) Having(conds ...gen.Condition) IEbUserBrokerageRecordDo {
	return e.withDO(e.DO.Having(conds...))
}

func (e ebUserBrokerageRecordDo) Limit(limit int) IEbUserBrokerageRecordDo {
	return e.withDO(e.DO.Limit(limit))
}

func (e ebUserBrokerageRecordDo) Offset(offset int) IEbUserBrokerageRecordDo {
	return e.withDO(e.DO.Offset(offset))
}

func (e ebUserBrokerageRecordDo) Scopes(funcs ...func(gen.Dao) gen.Dao) IEbUserBrokerageRecordDo {
	return e.withDO(e.DO.Scopes(funcs...))
}

func (e ebUserBrokerageRecordDo) Unscoped() IEbUserBrokerageRecordDo {
	return e.withDO(e.DO.Unscoped())
}

func (e ebUserBrokerageRecordDo) Create(values ...*model.EbUserBrokerageRecord) error {
	if len(values) == 0 {
		return nil
	}
	return e.DO.Create(values)
}

func (e ebUserBrokerageRecordDo) CreateInBatches(values []*model.EbUserBrokerageRecord, batchSize int) error {
	return e.DO.CreateInBatches(values, batchSize)
}

// Save : !!! underlying implementation is different with GORM
// The method is equivalent to executing the statement: db.Clauses(clause.OnConflict{UpdateAll: true}).Create(values)
func (e ebUserBrokerageRecordDo) Save(values ...*model.EbUserBrokerageRecord) error {
	if len(values) == 0 {
		return nil
	}
	return e.DO.Save(values)
}

func (e ebUserBrokerageRecordDo) First() (*model.EbUserBrokerageRecord, error) {
	if result, err := e.DO.First(); err != nil {
		return nil, err
	} else {
		return result.(*model.EbUserBrokerageRecord), nil
	}
}

func (e ebUserBrokerageRecordDo) Take() (*model.EbUserBrokerageRecord, error) {
	if result, err := e.DO.Take(); err != nil {
		return nil, err
	} else {
		return result.(*model.EbUserBrokerageRecord), nil
	}
}

func (e ebUserBrokerageRecordDo) Last() (*model.EbUserBrokerageRecord, error) {
	if result, err := e.DO.Last(); err != nil {
		return nil, err
	} else {
		return result.(*model.EbUserBrokerageRecord), nil
	}
}

func (e ebUserBrokerageRecordDo) Find() ([]*model.EbUserBrokerageRecord, error) {
	result, err := e.DO.Find()
	return result.([]*model.EbUserBrokerageRecord), err
}

func (e ebUserBrokerageRecordDo) FindInBatch(batchSize int, fc func(tx gen.Dao, batch int) error) (results []*model.EbUserBrokerageRecord, err error) {
	buf := make([]*model.EbUserBrokerageRecord, 0, batchSize)
	err = e.DO.FindInBatches(&buf, batchSize, func(tx gen.Dao, batch int) error {
		defer func() { results = append(results, buf...) }()
		return fc(tx, batch)
	})
	return results, err
}

func (e ebUserBrokerageRecordDo) FindInBatches(result *[]*model.EbUserBrokerageRecord, batchSize int, fc func(tx gen.Dao, batch int) error) error {
	return e.DO.FindInBatches(result, batchSize, fc)
}

func (e ebUserBrokerageRecordDo) Attrs(attrs ...field.AssignExpr) IEbUserBrokerageRecordDo {
	return e.withDO(e.DO.Attrs(attrs...))
}

func (e ebUserBrokerageRecordDo) Assign(attrs ...field.AssignExpr) IEbUserBrokerageRecordDo {
	return e.withDO(e.DO.Assign(attrs...))
}

func (e ebUserBrokerageRecordDo) Joins(fields ...field.RelationField) IEbUserBrokerageRecordDo {
	for _, _f := range fields {
		e = *e.withDO(e.DO.Joins(_f))
	}
	return &e
}

func (e ebUserBrokerageRecordDo) Preload(fields ...field.RelationField) IEbUserBrokerageRecordDo {
	for _, _f := range fields {
		e = *e.withDO(e.DO.Preload(_f))
	}
	return &e
}

func (e ebUserBrokerageRecordDo) FirstOrInit() (*model.EbUserBrokerageRecord, error) {
	if result, err := e.DO.FirstOrInit(); err != nil {
		return nil, err
	} else {
		return result.(*model.EbUserBrokerageRecord), nil
	}
}

func (e ebUserBrokerageRecordDo) FirstOrCreate() (*model.EbUserBrokerageRecord, error) {
	if result, err := e.DO.FirstOrCreate(); err != nil {
		return nil, err
	} else {
		return result.(*model.EbUserBrokerageRecord), nil
	}
}

func (e ebUserBrokerageRecordDo) FindByPage(offset int, limit int) (result []*model.EbUserBrokerageRecord, count int64, err error) {
	result, err = e.Offset(offset).Limit(limit).Find()
	if err != nil {
		return
	}

	if size := len(result); 0 < limit && 0 < size && size < limit {
		count = int64(size + offset)
		return
	}

	count, err = e.Offset(-1).Limit(-1).Count()
	return
}

func (e ebUserBrokerageRecordDo) ScanByPage(result interface{}, offset int, limit int) (count int64, err error) {
	count, err = e.Count()
	if err != nil {
		return
	}

	err = e.Offset(offset).Limit(limit).Scan(result)
	return
}

func (e ebUserBrokerageRecordDo) Scan(result interface{}) (err error) {
	return e.DO.Scan(result)
}

func (e ebUserBrokerageRecordDo) Delete(models ...*model.EbUserBrokerageRecord) (result gen.ResultInfo, err error) {
	return e.DO.Delete(models)
}

func (e *ebUserBrokerageRecordDo) withDO(do gen.Dao) *ebUserBrokerageRecordDo {
	e.DO = *do.(*gen.DO)
	return e
}
